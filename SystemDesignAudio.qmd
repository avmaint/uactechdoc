---
title: "System Design - Audio"
author: "UAC Media Arts"
execute: 
  eval: true
  echo: false
  warning: false
  message: false
format:
  html:
    toc: true
    toc-depth: 2
    toc-location: right
    number-sections: true
  pdf:
    number-sections: true 
    toc: true
    toc-depth: 2  
 
always_allow_html: yes
---

```{r options, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message=FALSE)
options(knitr.table.format = "html") # latex for pdf 
```

```{r setup}
source("commonPackages.R")

# require(readr)
# require(dplyr)
# require(readxl)
# require(knitr)
# require(formattable)
# require(kableExtra)
# require(glue)
# require(here)
```

```{r functions}
source("commonFunctions.R")
source("commonFunctionsAudio.R")
```

```{r getdata}
NetworkInventory <- get.network()
Tech_Inventory   <- get.inventory()
```

```{r dci}
#TODO: replace work.config with function calls.

ins <- work.config.dantedevices %>%
       filter(InOut == "In") %>%
       rename(DeviceIn = Device, 
              NetworkDeviceIn = NetworkDevice,
              NetworkDeviceChannelIn = NetworkDeviceChannel,
              LabelIn = Label,
              NotesIn = Notes)

outs <- work.config.dantedevices %>%
       filter(InOut == "Out") %>%
       rename(DeviceOut = Device,
              NetworkDeviceOut = NetworkDevice,
              NetworkDeviceChannelOut = NetworkDeviceChannel,
              LabelOut = Label,
              NotesOut = Notes)

console <- work.config.consoleinputs %>%
           filter(!is.na(NetworkDevice)) %>%
           rename(NetworkDeviceIn = NetworkDevice,
                  NetworkDeviceChannelIn =  NetworkDeviceChannel)

t1 <- merge(ins , work.config.dantepatch)  
t2 <- merge(t1, outs, by=c("NetworkDeviceOut", 
                           "NetworkDeviceChannelOut"))
dante.console.ins <- merge(t2, console )
```

# Introduction

This document provides key technical documentation for the Sanctuary audio subsystems at UAC. Other audio systems are not documented to this level of detail (Youth, Children).

Purpose:

* Necessary to help the hearing impaired ( roughly 10% of the population) to lip read
* Supports video recording
* Helps draw attention to the central item â€“ conversely makes it easier to ignore clutter
* Helps audience to focus and concentrate
* Reinforces the message (spoken or sung)

{{< pagebreak >}} 
# Configuration

The descriptions of the configurations will generally start at the input side of the system and work towards the outputs.


```{dot overview}
//| label: fig-audio-overview
//| fig-cap: "Audio system overview."
//| file: gv/sda-overview.gv
``` 
 
## Inputs

There are a variety of microphone inputs that come from the stage as well as CD players, tape players and computer inputs in the balcony. These all are fed into one of two audio mix consoles: A Yamaha M7CL-48 and a Yamaha DM1000. The M7CL is the primary console while the DM1000 handles inputs located at the mix position. Some of those inputs also feed the livestream DAW.

```{dot sda-inputs-m7}
//| label: fig-sda-inputs-m7
//| fig-cap: "M7CL Inputs"
//| file: gv/sda-inputs-m7.gv
``` 

### M7CL Input Assignments

Having a consistent wiring plan helps make system more predictable and easier for all audio engineers to use. The consistent wiring plan is also essentail to leveage the power of console's scene recall feature. It minimizes the amount of rewiring required. See @tab-sda-inputs-m7-map

The chart which follows is the standard input map if using Scene 014. 

```{r m7in}
#| label: tab-sda-inputs-m7-map
#| fig-cap: "M7CL Inputs"
get_inputs("M7CL", "002") %>% 
	gt() |>
	opt_stylize(style=3) |>
	tab_header("M7CL Input Map") 
```


```{r m7.dante}
#| label: tab-sda-inputs-m7-dante
#| tab-cap: "M7CL Inputs via Dante"
di <- "ZAKU-0001"

dante.console.ins %>% 
  filter(DeviceIn == di) %>%
  mutate(Card.In = glue("{NetworkDeviceIn}:{NetworkDeviceChannelIn}")) %>%
  mutate(ComesFrom = glue("{NetworkDeviceOut}:{NetworkDeviceChannelOut}")) %>%
  select(Channel,
    Card.In, LabelIn, NotesIn, 
         ComesFrom , 
         LabelOut, NotesOut
         ) %>%
  arrange(   Channel) %>%
  kable( caption=glue("Dante Input Mapping for {di}")  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover"))
```
 
### DM1000 Inputs

The DM1000 inputs are all located in the FoH mix position. The chart below describes Scene 014 default definitions. See @fig-sda-inputs-dm and @tab-sda-inputs-dm-map

```{dot sda-inputs-dm}
//| label: fig-sda-inputs-dm
//| fig-cap: "DM1000 Inputs"
//| file: gv/sda-inputs-dm.gv
```
 
```{r dmin}
#| label: tab-sda-inputs-dm-map
#| tab-cap: "DM1000 Inputs"
get_inputs("DM1K", "002") |>
 	gt() |>
	opt_stylize(style=3) |>
	tab_header("DM1000 Input Map") 
```

```{r dm.dante}
#| label: tab-sda-inputs-dm-dante
#| tab-cap: "DM1000 Inputs via Dante"
di <- "ZAKU-0002"

dante.console.ins %>% 
  filter(DeviceIn == di) %>%
  mutate(Card.In = glue("{NetworkDeviceIn}:{NetworkDeviceChannelIn}")) %>%
  mutate(ComesFrom = glue("{NetworkDeviceOut}:{NetworkDeviceChannelOut}")) %>%
  select(Channel,
    Card.In, LabelIn, NotesIn, 
         ComesFrom , 
         LabelOut, NotesOut
         )  %>%
  arrange(   Channel) %>%
  kable( caption=glue("Dante Input Mapping for {di}")  ) %>%
    kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r top1}
print_inv(c( "CDMU-A001", "ZAKU-0002",
             "ZAKU-0001", "ZAPU-0001",
             "ZAMU-A001", "ZAMU-B001", "ZAMU-B002", "ZAMU-B003",
             "ZAIU-B001", "ZAIU-B002",
             "ZAHU-0005", "ZAHU-0006"
             ), Tech_Inventory)
```

## Front of House

### Consoles

As introduced in the earlier section there are two primary mix consoles in the Santurary System. Both of these consoles are digital with full scene store and recall. Recalling scene 014 on the M7CL will cause both consoles to reset to our standard starting point which is an excellent foundation for 95% of the services we run in a year. 

The DM1000 (sometimes referred to as DM1K) is the secondary console which collects the inputs for most of the FOH located gear: players, computers, and some of the wireless receivers. It in turn supplies audio to the main console via bus level links (via IO cards on each console). 

The M7CL is the primary mixing consol for vocal and instrumentals. The outputs from this console drive the house, lobby and monitor speakers.

There are some additional outboard components which complete the signal path. The main house output flows through a TC Electronics Finalizer, which provides multi-band compression. The output of that then goes two directions. one channel feeds the audio recording subsystem and the other feeds into the FOH DSP- and BSS soundweb.

The monitor amps are feed directly from the M7CL. The house amps are feed from the soundweb.

 
```{dot fig-sda-foh}
//| label: fig-sda-foh
//| fig-cap: "Front of House"
//| file: gv/sda-foh.gv
```

```{r}
cs <- c( 
"ZAKU-0001",
"ZAXU-0002",
"ZAXU-0001",
"ZAXU-0003",
"ZAXU-0004",
"ZAHU-0001", "ZAHU-0005", "ZAHU-0002", "ZAHU-0001", "ZAHU-0006",
"ZVKU-A003", "ZAIU-E001")

print_inv(cs , Tech_Inventory)
```

### Other FoH gear

These can all be found in the diagram above.

#### Finalizer

The finalizer is used to apply multi-band compression to the FOH signal. It gets signal from the Console main stereo bus.

The Left channel goes and the Soundweb or Dominator.
The Right channel goes and the Soundweb or Dominator.

>TODO: resolve which - Left or Right
>TODO: Document settings.

#### Rane DA

This is an audio distribution amplifer. 

#### Dominator II

The settings for this device are all manual and not "storeable". See @dom_settings.

```{r dom_settings}
#| label: dom_settings
#| tap-cap: Dominator Settings
#| cap-location: bottom

dom <- tribble(
  ~Parameter, ~Setting,
  "Input Gain", "0",
  "Process", "In",
  "LF EQ", "0",
  "XOver1", "100",
  "HF EQ", "-2",
  "XOver2", "34",
  "Release", "23",
  "Stereo Coupling", "On",
  "RCH Density", "0",
  "Fine", "+2",
  "Range", "-10",
  "Course", "12"
)

dom |> 
  gt() |>
  opt_stylize(style=3) |>	
  tab_header("Dominator Settings")	
```

#### SoundWeb

The soundweb settings are all stored in memory. 

#### Lobby Speakers

One of the outputs of the RANE DA is connected to the lobby amplifier, a Stuart Audio Hub. This in turn drives four 10W amplifiers which are mounted on the speakers in the lobby ceiling. Signal and power distribution is via Cat5 cable (it is __not__ ethernet). 

```{r lobby}
lobby <-' 
graph bfs { 
  
graph [overlap = true, fontsize = 20, 
      label="Lobby Audio Topology\n(as of 2019-06-10)",
      fontname = Helvetica, bgcolor=white, rankdir=LR
      ]
 
node [shape = Mrecord style=filled , fillcolor="white:beige"  , fontsize = 10,
      gradientangle=270 fontname = Helvetica ]
  
  subgraph cluster_rack { label="ZVHU-____ rack"  
                              tooltip="Front desk Rack"
        rane                       
        ZAAU0009 [label="{Audio Hub|ZAAU-009}", 
                      tooltip="Stuart"]
  }

ZAAU0010A  [label="Speaker with Amp\nZAAU-0010 A", tooltip="Speaker"]
ZAAU0010B  [label="Speaker with Amp\nZAAU-0010 B", tooltip="Speaker"]
ZAAU0010C  [label="Speaker with Amp\nZAAU-0010 C", tooltip="Speaker"]
ZAAU0010D  [label="Speaker with Amp\nZAAU-0010 D", tooltip="Speaker"]
 
rane -- ZAAU0009  
ZAAU0009 -- ZAAU0010A [label="cat5"]
ZAAU0009 -- ZAAU0010B [label="cat5"]
ZAAU0009 -- ZAAU0010C [label="cat5"]
ZAAU0009 -- ZAAU0010D [label="cat5"]
} 
'

DiagrammeR::grViz(lobby, height=350)
```



#### Inventory details for this section

```{r}
cs <- c("ZAXU-0003", "ZAXU-0004", "ZAAU-0009", "ZAAU-0010")

print_inv(cs , Tech_Inventory)
```

### Console Links

There is are ADAT IO expansion card in each of the two consoles. This enables console-to-console communication. The buses in the DM1000 console are linked to the buses in the M7 using these cards. The Flow is from the DM1000 to the M7. The link cards are in slot one of each console.

There is also a midi link between the two which enables synchronized scene recall.

```{dot sda-links}
//| label: fig-sda-links
//| fig-cap: "Console Links"
//| file: gv/sda-links.gv
```

More detail about the Dante configuration can be found in the Dante section.

```{r lnks}
links <- tribble(
~Console, ~Slot, ~Direction, ~Channel, ~Assignment,
"DM1K", 1, "Out", "1-6",   "Monitor 1-6",
"DM1K", 1, "Out", "8",     "Record",
"DM1K", 1, "Out", "15-16", "Stereo LR",
"M7CL", 1, "In",  "1-6",   "Mix 1-6",
"M7CL", 1, "In",  "8",     "Mix 14",
"M7CL", 1, "In",  "13-14", "Cue LR",
"M7CL", 1, "In",  "15-16", "Stereo LR",
"M7CL", 1, "In",  "16",    "Mono",
"M7CL", 2, "In",  "1-10",  "Wireless Handheld",
"DM1K", 2, "In",  "1-6",   "Wireless Beltpack"
) |>
	mutate(Group = paste(Console, Slot, Direction))

links %>%
  gt(rowname_col = "Assignment", groupname_col="Group") |>
  opt_stylize(style=3)  
   
```


### M7 Mix Bus Usage

This console has 16 mix busses. Since the console is capable of multiple routing paths within the console. This is described by the 'And then' description which informs about what happens next within the console.

>TODO: Update @tab-m7-busses with DAW details 

```{r m7_busses}
#| label: tab-m7-busses
#| tab-cap: M7 Bus Usage
#| cap-location: bottom
tribble( 
~MixNo, ~Description, ~And_then 
, 1, "Monitor 1", "To Rack EQ and then out to Omni 1" 
, 2, "Monitor 2", "To Rack EQ and then out to Omni 2" 
, 3, "Monitor 3", "To Rack EQ and then out to Omni 3" 
, 4, "Monitor 4", "To Rack EQ and then out to Omni 4" 
, 5, "Monitor 5", "To Rack EQ and then out to Omni 5" 
, 6, "Monitor 6", "To Rack EQ and then out to Omni 6"   
, 7, "Effect- Reverb plate", "To Rack 5 and then to STRIN 1" 
, 8, "Effect- Rev-X Hall", "To Rack 6 and then to STRIN 2" 
, 9, "Effect- mono Delay",  "To Rack 7 and then to STRIN 3" 
,10, "Effect- Chorus", "To Rack 8 and then to STRIN 4"  
,11, "", "" 
,12, "","" 
,13, "",""
,14,"Record Mix","Out on Omni 14" 
,15, "",""
,16, "",""
) |>
	gt() |>
	opt_stylize(style=3)
```

## Amplifiers

Now lets finish our journey to the speakers.  

```{dot sda-outputs}
//| label: fig-sda-outputs
//| fig-cap: "Outputs"
//| file: gv/sda-outputs.gv
```

>TODO: update the chart below to reflect the amplifier list.

```{r tab-amp-list}
#| label: tab-amp-list
#| tab-cap: List of Amplifiers
#| cap-location: bottom
selected <- c( "ZAAU-0005", "ZAAU-0006", "ZAAU-0011" 
           , "ZAAU-0007",  "ZAAU-0001" #"ZAAU-0008",
           , "ZAAU-0002", "ZAAU-0003", "ZAAU-0004", "2309-0914")
print_inv(selected, Tech_Inventory)
```

## Speakers

We have speakers in several locations:

* Main cluster for Front of House which is suspended in front of the stage.
* Monitor speakers on the stage floor
* FoH fill speakers above the balcony and underneath the balcony
* in the lobby ceiling

The FoH cluster is positioned to make the cross-over between the side and centre speaker fall down the centre two aisles. There is some high frequency fall off in the front two rows.

The monitors speakers should be wired for __at most__ two speakers per channel (amp). 

```{r}
cs <- c("ZASU-0001-0002",
"ZASU-0003-0005",
"ZASU-0006-0011",
"ZASU-0012-0019",
"ZASU-0020-0021")

print_inv(cs , Tech_Inventory)
```

 

{{< pagebreak >}} 
# Dante Configuration

Dante enables certain audio devices to route audio signals using standard network technologies. Routing is managed via software provided by Audinate called "Dante Controller".  

Several audio devices are Dante capable, including both mixers, the Shure wireles microphones and the computers.

The Dante card in the M7CL is set as the preferred master clock and the first channel on that card is tied to the console clock. **The system clock is set to 48kHz.**

As well as the controller software there are two other software titles that provide the capabilities. 

Dante Virtual Soundcard
: This title is licensed for all three computers and enables the computer to send and receive multiple channels of audio over the network as if it were attached via a traditional sound card.
 
Dante VIA
: This title is also licensed for all three computers. It enables the routing of audio for specific applications within the computer and also within the Dante network.

Dante Controller
: This is free software. It is used to manage the Dante network and provides virtual patchbay capabilities to link sources (transmitters) and sinks (receivers).

Visit [https://www.audinate.com](https://www.audinate.com) to learn more about Dante. Audinate have a very good certification series of videos on youtube.

## Dante Network Topology
This is the network topology.

```{dot sda-dante}
//| label: fig-sda-dante
//| fig-cap: "Dante Network"
//| file: gv/sda-dante.gv
```


```{r}
cs <- c("ZAIU-B001", "ZAIU-B002" ,
        "ZAMU-A001", "ZAMU-B001", "ZAMU-B002", "ZAMU-B003",
         "NSCU-A003", "NSCU-A004", 
        "CDWU-0009", "CDMU-A001", "CDMU-A002",
        "ZAIU-E001", "ZAIU-E002"
        )

print_inv(cs , Tech_Inventory)
```

## Dante Standard Patch

The patching between inputs and output is managed by "Dante Controller" software on a computer.  
  
```{r matrixdata}
devices <- tribble(
~AssetTag, ~Desc, ~isTransmitter, ~isReceiver,
"ZAIU-B001", "IO card in M7CL", TRUE, TRUE,
"ZAIU-B002", "IO card in DM1K", TRUE, TRUE,
"ZAMU-A001", "SHURE ULXD",      TRUE, FALSE,
"ZAMU-B001", "SHURE ULXD",      TRUE, FALSE,
"ZAMU-B002", "SHURE ULXD",      TRUE, FALSE,
"ZAMU-B003", "SHURE ULXD",      TRUE, FALSE,
"CDWU-0009", "Computer",        TRUE, TRUE,
"CDMU-A001", "Computer",        TRUE, TRUE,
"CDMU-A002", "Computer",        TRUE, TRUE
)

io.card <- data.frame(AssetTag="",
                      Dir=c(rep("T",16),rep("R",16)),
                      Num=c(seq(1,16), seq(1,16)) )  

ZAIUB001 <- io.card
ZAIUB001$AssetTag <- "ZAIU-B001" 
ZAIUB002 <- io.card
ZAIUB002$AssetTag <- "ZAIU-B002"

shure <- data.frame(AssetTag="",
                      Dir= rep("T",4) ,
                      Num= seq(1,4)  )

ZAMUA001 <- shure  
ZAMUA001$AssetTag <- "ZAMU-A001" 

ZAMUB001 <- shure
ZAMUB001$AssetTag <- "ZAMU-A001" 

ZAMUB002 <- shure
ZAMUB002$AssetTag <- "ZAMU-B002" 

ZAMUB003 <- shure
ZAMUB003$AssetTag <- "ZAMU-B003" 

comp <- data.frame(AssetTag="",
                   Dir=c(rep("T",2),rep("R",2)),
                   Num=c(seq(1,2),  seq(1,2)) )

CDWU0009 <- comp  
CDMUA001 <- comp  
CDMUA002 <- comp
CDWU0009$AssetTag <- "CDWU-0009"  
CDMUA001$AssetTag <- "CDMU-A001"  
CDMUA002$AssetTag <- "CDMU-A002"

channels <- rbind(ZAIUB001, ZAIUB002,
                  ZAMUA001, ZAMUB001, ZAMUB002, ZAMUB003,
                  CDWU0009, CDMUA001, CDMUA002)

channels$Name <- paste0(channels$AssetTag,"-",channels$Num)

xmtrs <- channels %>% filter(Dir=="T")
rcvrs <- channels %>% filter(Dir=="R")

col.names <- xmtrs %>% select(Name) %>% pull()
row.keys  <- rcvrs %>% select(Name, Num)

routing <- data.frame(matrix(ncol=nrow(xmtrs)+1, nrow=38))
colnames(routing) <- c("Name", col.names) 

r2 <- rcvrs %>% select(Name )
routing$Name <- r2$Name

pairs <- tribble(
  ~x, ~r,
  #wireless Handhelds
  "ZAMU-A001-1",  "ZAIU-B001-1",
  "ZAMU-A001-2",  "ZAIU-B001-2",
  "ZAMU-A001-3",  "ZAIU-B001-3",
  "ZAMU-A001-4",  "ZAIU-B001-4",
  "ZAMU-B001-1",  "ZAIU-B001-5",
  "ZAMU-B001-2",  "ZAIU-B001-6",
  "ZAMU-B001-3",  "ZAIU-B001-7",
  "ZAMU-B001-4",  "ZAIU-B001-8",
  "ZAMU-B002-1",  "ZAIU-B001-9",
  "ZAMU-B002-2",  "ZAIU-B001-10",
  
  #wireless beltpacks
  "ZAMU-B002-3",  "ZAIU-B002-1",
  "ZAMU-B002-4",  "ZAIU-B002-2",
  "ZAMU-B003-1",  "ZAIU-B002-3",
  "ZAMU-B003-2",  "ZAIU-B002-4",
  "ZAMU-B003-3",  "ZAIU-B002-5",
  "ZAMU-B003-4",  "ZAIU-B002-6"
)

for (i in 1:nrow(pairs)) {
  x <- pairs[i,]$x
  r <- pairs[i,]$r
  routing[routing$Name == r,x] <- 1
}
```

```{r printmatixall, eval=FALSE}

routing  %>% 
    mutate( rs = rowSums( .[,2:ncol(.)] ,na.rm=TRUE)) %>%
    filter(rs >0) %>%
    select(-rs) %>%
    kable(caption="Whole Routing Matrix", format = "html") %>%
    kable_styling("striped" , full_width= F) %>%
    row_spec(0, angle=-90) %>%
    kable_styling(bootstrap_options = c("striped", "hover"))
```


```{r printmatixhh}

routing %>%  
    select("Name", starts_with("ZAMU-A"),
                   starts_with("ZAMU-B001"),
                  "ZAMU-B002-1", "ZAMU-B002-2"
           ) %>%    
    select(-contains(".")) %>% #Dont know how these columns are created
    mutate( rs = rowSums( .[,2:ncol(.)] ,na.rm=TRUE)) %>%
    filter(rs >0) %>%
    select(-rs) %>%
    mutate_all(funs(ifelse(is.na(.), "", .))) %>%
    kable(caption="Wireless Handheld Sources", format = "html") %>%
    kable_styling("striped" , full_width= F) %>%
    row_spec(0, angle=-90) %>%
    kable_styling(bootstrap_options = c("striped", "hover"))
```

```{r printmatrixbp}
routing %>%  
    select("Name",  
                   starts_with("ZAMU-B003"),
                  "ZAMU-B002-3", "ZAMU-B002-4"
           ) %>%
    mutate( rs = rowSums( .[,2:ncol(.)] ,na.rm=TRUE)) %>%
    filter(rs >0) %>%
    select(-rs) %>%
    mutate_all(funs(ifelse(is.na(.), "", .))) %>%
    kable(caption="Wireless Beltpacks Sources", format = "html") %>%
    kable_styling("striped" , full_width= F) %>%
    row_spec(0, angle=-90 )
```

# Livestream Configuration 

## Primary Dante Configuration

The primary configuration is depcted in @fig-livestream-audio1

* Reaper runs on CUMU-E001
* DVS on the computer is configured at 48x48 mode.
* The Shure wireless untis are directly input to this computer
* The M7Cl sends 16 outputs also into to this computer. These are a mix of direct outputs and submixes.
* FUTURE the other three computers will send their audio directly to this computer.
* Repaer audio devices to be configured to use Dante for both input and output
* Reaper is configured to send two outputs for monitoring and two outputs for the livestream.

```{dot fig-livestream-audio1 }
//| fig-cap: Audio Feed to Video
//| label: fig-livestream-audio1
//| cap-location: bottom

digraph livestream_audio1 { 
  
graph [overlap = true, fontsize = 20, 
      label="Primary Audio Feed to Video\n(as of 2022-03-19)",
      fontname = Helvetica, bgcolor=white, rankdir=LR
      ]
 
node [shape = Mrecord style=filled , fillcolor="white:beige"  , fontsize = 10,
      gradientangle=270 fontname = Helvetica ]

cumue001
 [label="
{
  {Mac Mini|Reaper|CUMU-E001} 
|{
  <o01>Livestream L   
  <o02>Livestream R
  <o03>RefMon L
  <o04>RefMon r   
}
}
"]

avio  [label="{{
  <net>net
} | {avio|2308-1124}|{<o1>Ch1|<o2>Ch2} }"]


videomix  [label="{{<i1>L|<i2>R } |{Video\nMixer|ZVKU-A003}|<o1>SDI}"]
resi  [label="{{<i1>SDI } |{Resi Encoder|ZVIU-D002}}"]

cumue001:o01 -> avio:ch1 [label="dante"]
cumue001:o02 -> avio:ch2 

avio:ch1 -> videomix:i1
avio:ch2 -> videomix:i2

videomix:o1 -> resi:i1
} 
```


## Backup Dante Configuration

In the event of a problem with the reaper computer or short staffed and the livestream needs to be mixed by Foh, Change the routing of the M7CL bus 14 to go directly to the avio adapter connected to the video mixer, via Dante Controller. The audio mix can now be performed on the record bus ... #14. See @@fig-livestream-audio2


```{dot fig-livestream-audio2}
//| fig-cap: Audio Feed to Video
//| label: fig-livestream-audio2
//| cap-location: bottom

digraph livestream_audio2 { 
  
graph [overlap = true, fontsize = 20, 
      label="Backup Audio Feed to Video\n(as of 2022-03-19)",
      fontname = Helvetica, bgcolor=white, rankdir=LR
      ]
 
node [shape = Mrecord style=filled , fillcolor="white:beige"  , fontsize = 10,
      gradientangle=270 fontname = Helvetica ]

ZAKU0001
 [label="
{
  
  {Dante card|M7CL |ZAIU-E002} 
|{
  <S215>Slot2-15
}
}
"]

avio  [label="{{
  <net>net
} | {avio|2308-1124}|{<o1>Ch1|<o2>Ch2} }"]


videomix  [label="{{<i1>L|<i2>R } |{Video\nMixer|ZVKU-A003}|<o1>SDI}"]
resi  [label="{{<i1>SDI } |{Resi Encoder|ZVIU-D002}}"]

ZAKU0001:s215 -> avio:ch1 [label="dante"]
ZAKU0001:s215 -> avio:ch2 

avio:ch1 -> videomix:i1
avio:ch2 -> videomix:i2

videomix:o1 -> resi:i1
} 
```


## Fallback to Analog Configuration

If this is ever required, take the audio output direclty from the RANE output via mic cable to the video mixer. Audio levels in the video mixer will need to be checked and adjusted. This can be done directly on the panel interface or via the ATEM control software, Audio section. See @fig-livestream-analog-backup.

```{dot fig-livestream-analog-backup}
//| fig-cap: Livestream Analog Backup
//| cap-location: bottom
//| label: fig-livestream-analog-backup 
 
digraph outputs { 
graph [overlap = true, fontsize = 30, rankdir=LR 
      label="Audio Outputs (as of 2023-09-14)",
      fontname = Helvetica]

node [shape=Mrecord, tooltip="" ,  fontsize = 10,
      fillcolor="white:beige" , style=filled  
      gradientangle=270]

m7 [label="
{{    Yamaha\nM7CL\nZAKU-0001} 
|{
  <o14>Out 14
| <o15>Out 15  
| <o16>Out 16
}}
"]

subgraph cluster_foh1 {label="Rack ZAHU-0005" fontsize=12

final [label="
{
  {
  <il>L  
| <ir>R  
} |
  {Finializer\nZAXU-0002} 
|{
  <ol>L  
| <or>R  
}
}
"]

}
subgraph cluster_foh2 { label="Rack ZAHU-0006" fontsize=12
dom [label="
{
  {
  <il>L  
| <ir>R  
} |
  {Dominator\nZAXU-0003} 
|{
  <ol>L  
| <or>R  
}
}
"]

rane [label="
{
  {
  <il>L  
| <ir>R  
} |
  {Rane DA\nZAXU-0004} 
|{
  <o3>3
| <o4>4
 }
}
"]
}

m7:o14 -> final:il
m7:o16 -> final:ir

final:ol -> dom:il
dom:ol -> rane:il

videomix  [label="{{<i1>ch1|<i2>ch2 } |{Video\nMixer|ZVKU-A003}|<o1>}"]

rane:o3 -> videomix:i1
rane:o4 -> videomix:i2
} 
```

# Network Details
Some of the audio system components have network (tcp/ip specicially) connectivity requriements. The primary audio console can be remotely operated from an iPad, so other devices also must be on the network as well, but they are personal devices and not part of this inventory. In the balcony, network switch NSCU-A003 provides wired access.    

```{r ni716} 
 NetworkInventory %>% 
  filter(Category=="Audio") %>% 
  select(AssetTag, Usage, Device, MAC, IP, URL, Notes) %>%
  kable()  %>%
    kable_styling("striped", full_width = TRUE)
```

{{< pagebreak >}} 

# Equipment Inventory

```{r inventory, echo=FALSE, asis=TRUE}

cs = c("AssetTag", "Qty"  ,
  "Manufacturer" ,
  "Model"  , 
  "Qty",
  "Location"  ,
  "Type" ,
  "Desc"     )

Tech_Inventory %>%  
          filter( Category=="Audio" , InService== "Y") %>%  
          dplyr::select(one_of(cs)) %>% 
          kable(   )   %>%
    kable_styling("striped", full_width = TRUE)
```

 

{{< include common_trailer.qmd >}}

# Input Map for Printing
{{< pagebreak >}} 
```{r ToPrint}
include <- c(seq(1,32), seq(41,46))

g0 <- get_inputs("M7CL", "002") |>
	  select( Channel, Usage ,Type , Notes ) |>
  filter(Channel %in% include) 

g1 <- g0[1:19, ]
g2 <- g0[20:38,]
g3 <- cbind(g1, g2)

# g3 %>% # only pprint what is relevant to the stage box
#   kable(caption="M7CL Input Map") %>%
#     column_spec( 1:2,  bold = TRUE ) %>%
#       column_spec( 5:6,  bold = TRUE ) %>%
#       column_spec( 4,  extra_css = "border-right:3px solid black;" ) %>%
#       column_spec( 8,  extra_css = "border-right:3px solid black;" ) %>%
#       column_spec( 1,   extra_css = "border-left:3px solid black;" ) %>%
#       row_spec(19, extra_css = "border-bottom:3px solid black;") %>%
#     row_spec(1, extra_css = "border-top:3px solid black;") %>%
#     kable_styling("striped", full_width = TRUE)
```

```{r m7cl_inputs_printable}
# gt version
g1a <- g1
g2a <- g2

colnames(g1a)<-paste(colnames(g1a),"A",sep="_")
colnames(g2a)<-paste(colnames(g2a),"B",sep="_")

g3a <- cbind(g1a, data.frame(blank=rep("|",19)), g2a)

g3a |>
	select( 
		Channel_A, Usage_A ,Type_A , Notes_A ,
		blank,
        Channel_B ,Usage_B,Type_B , Notes_B ) |>
	gt() |>
	sub_missing(   missing_text = "---" ) |>
	tab_style(
    style = cell_borders(
      sides = c("left","right") ,
      color = "red",
      weight = px(5),
      style = "solid"
    ),
    locations = cells_body(columns = "blank", rows = everything())
  ) |>
	tab_style(
    style = cell_borders(
      sides = c("left") ,
      color = "red",
      weight = px(5),
      style = "solid"
    ),
    locations = cells_body(columns = "Channel_A", rows = everything())
  ) |>
	tab_style(
    style = cell_borders(
      sides = c("right") ,
      color = "red",
      weight = px(5),
      style = "solid"
    ),
    locations = cells_body(columns = "Notes_B", rows = everything())
  ) |>
	tab_style(
    style = cell_borders(
      sides = c("top") ,
      color = "red",
      weight = px(5),
      style = "solid"
    ),
    locations = cells_body(columns = contains("_"), rows = Channel_A == 1 )
  ) |>
	tab_style(
    style = cell_borders(
      sides = c("bottom") ,
      color = "red",
      weight = px(5),
      style = "solid"
    ),
    locations = cells_body(columns = contains("_"), 
    					   rows = Channel_A == 19 )
  ) |>
	cols_label  (
    Channel_A = "Channel",
    Usage_A = "Usage",
    Type_A = "Type",
    Notes_A = "Notes",
     Channel_B = "Channel",
    Usage_B = "Usage",
    Type_B = "Type",
    Notes_B = "Notes",
     blank = "|"
    )  
```


```{r dod, eval=FALSE}
# Dante Output Dump

o1 <- work.config.consoleoutputs
o2 <- work.config.dantepatch

do <- "ZAKU-0001"

merge(o1, o2) %>%
  arrange(NetworkDeviceOut, NetworkDeviceChannelOut) %>%
  mutate(Sent.To = glue("{NetworkDeviceIn}:   {NetworkDeviceChannelIn}")) %>% 
  mutate(Sent.From = glue("{NetworkDeviceOut}:{NetworkDeviceChannelOut}")) %>%
  select(Output, Sent.From, Label, Usage, 
         Sent.To
         ) %>%
  kable(caption=glue("Dante Outputs for {do}"))  %>%
    kable_styling(bootstrap_options = c("striped", "hover"))
```
